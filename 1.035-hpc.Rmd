---
output:
  pdf_document: default
  html_document: default
---
# High Performance Computing Clusters (HPCC's)

One interesting aspect of modern next generation sequencing data is simply its
sheer size:  it is not uncommon to receive a half or a full terabyte of data from
a sequencing center.  It is impractical to store this much data on your
laptop, let alone analyze it there.  Crunching through such a quantity of data on a single
computer or server could take a very long time.  Instead, you will likely break
up the analysis of such data into a number of smaller jobs, and send them off to
run on an assortment of different computers in a High Performance Computing Cluster (HPCC).  

Thus, even if you have immersed yourself in bioinformatic data file formats and honed
your skills at shell programming and accessing remote computers, sequence data analysis
remains such a formidable foe that there is still one last key area of computing
in which you must be fluent, in order to comfortably do bioinformatics: you must understand
how to submit and manage jobs sent to an HPCC.  

My first experience with HPCC's occurred when I started analyzing
high-throughput sequencer output.  I had over 15 years experience in shell
programming at that time, and I was given some example analysis scripts to emulate, but I still
found it took several weeks before I was moderately comfortable in an HPCC environment.  Most
HPCC's have some sort of tutorial web pages that provide a little bit of background
on cluster computing, but I didn't find the ones available to me, at the time, to
be particularly helpful.  

The goal of this chapter is to provide the sort of background I wish that I had
when I started doing cluster computing for bioinformatics.  I will not be providing
a comprehensive overview of parallel computation. For example, we will not focus at all
upon the rich tradition of parallel computing applications through "message passing" interfaces which
can maintain a synchronized analysis from a single program executing
on multiple computers at the same time.  Rather, we will focus on the manner in which
most bioinformatic problems can be broken down into a series of smaller jobs,
each of which can be run, independently, on its own processor without the
need for maintaining synchrony between multiple processes.  

We start with an overview of what an HPCC consists of, defining a few important
terms. Then we provide some background on the fundamental problem of cluster
computing: namely that a lot of people want to use the computing power of the cluster,
but it needs to be allocated to users in an equitable fashion.  An understanding of this
forms the basis for our discussion of _job scheduling_ and the methods you must
use to tell the _job scheduler_ what resources you will need, so that those resources
will eventually be allocated to you.  We will cover a job scheduler called SLURM, which
stands for the Simple Linux Utility for Resource Management.  It is the scheduler used
on the Summit supercomputer in Boulder and the Hummingbird and Sedna clusters deployed
at UCSC and the NWFSC, respectively.  

After a discussion of SLURM, we will wrap up the chapter with a look at
methods for installing software to use for your analyses.

## An oversimplified, but useful, view of a computing cluster

At its simplest, an HPCC can be thought of as a whole lot of computers that are all
put in a room somewhere for the purposes of doing a lot of computations.  Most of these
computers do not possess all the elements that typically come to mind when you
think of a "computer."  For example, none of them are attached to monitors---each
computer resembles just the "box" part of a desktop computer.  Each of these "boxes" is called
a _node_. The node is the unit in a cluster that corresponds most closely to what you think of
as a "computer."  As is typical of most computers today, each of these nodes has some
amount of Random Access Memory (RAM) that is _only accessible by the node itself_.  RAM
is the space in memory that is used for active computation and calculation.

Each of these
nodes might also have a hard drive used for operating system software.  The bulk of the
hard drive space that each node can access, however, is in the form of a large array of hard disks
that are connected to _all_ of the nodes by an interface that allows data to be transferred
back and forth between each node and the hard-drive array at speeds that would be expected of
an internal hard drive (i.e., this array of hard drives is not just plugged in with a USB
cable). Memory on hard drives is used for storing data and the results of calculations, but
is not used for active calculations the way RAM is used.  In order for calculations to be done
on data that are on the hard drive array, it must first be read into a node's RAM.  After the calculations
are done, the results are typically written back out onto the hard drive array.

On a typical cluster, there are usually several different "portions" of the hard drive
array attached to every _node_.  One part of the array holds _home directories_ of the
different users.  Each user typically has a limited amount of storage in their home directory, but
the data in these home directories is usually safe or protected, meaning you can put a file there
and expect that it will be there next week, month, or year, etc. It is also likely that the home directories are
backed up (but check the docs for your cluster to confirm this!). Since the space in home directories is limited,
you typically will not put large data sets in your home directory for long-term storage, but you will
store scripts and programs, and such items as cloned GitHub repositories there.  Another
type of storage that exists on the hard drive array is called _persistent long-term storage_.  This type of storage
is purchased for use by research groups to store large quantities of
data on the cluster for long periods of time.  As discussed in the last chapter, the rise of cloud-based storage solutions,
like Google Drive, offering unlimited storage to institutional users makes persistent long-term storage less
important (and less cost-effective) for many research groups.  Finally, the third type of
storage in the hard drive array is called _scratch storage_.  There are usually fairly
light limits (if any at all) to how much data can be placed in scratch storage, but there
will typically be Draconian _time limits_ placed on your scratch storage.  For example, on the
Hoffman2 cluster at UCLA, you are granted 2 Tb of `scratch` storage, but any files that
have sat unmodified in `scratch` for more than 14 days will be deleted (and if space is tight, the
system administrators may delete things from `scratch` in far fewer then 14 days.)  Check
your local cluster documentation for information about time and space limits on `scratch`.

On many clusters, scratch space is also configured to be very fast for input and output
(for example, on many systems, the scratch storage will be composed of solid state drives rather
than spinning hard disks).  On jobs that require that a lot of data be accessed from the
drive or written to it (this includes most operations on BAM files), significant decreases
in overall running time can be seen by using fast storage. Finally, scratch space exists on a cluster
expressly as _the place_ to put data and outputs on the hard drive _when running jobs_.  For all these
reasons, when you run jobs, you will always want to read and write data from and to `scratch`.  We
will talk more about the specifics of doing so, but for now, you should be developing a generic picture
of your cluster computing workflow that looks like:

1. Download big data files from the cloud to `scratch`
2. Run analyses on those data files, writing output back to `scratch`.
3. When done, copy, to the cloud, any products that you wish to keep.
4. Remove data and outputs left on `scratch`.

As is the case with virtually all modern desktop or laptop computers, within each node,
there are multiple (typically between 16 and 48) _cores_,  which are the computer chip units that actually
do the computations within a node. A _serial job_ is one that just runs on a single core
within a _node_, while a _parallel job_ might run on multiple cores, at the same time, within
a single node.  In such a parallel job, each core has access to the same data within the
node's RAM (a "shared-memory," parallel job).  The _core_
is the fundamental unit of computing machinery that gets allocated to perform jobs in an HPCC.

Most of the nodes in a cluster are there to hold the cores which are the computational workhorses,
slogging through calculations for the HPCC's myriad users.  However, some nodes
are more appropriate to certain types of computations than others (for example, some
might have lots of memory for doing genome assembly, while others will have
big, hurkin', graphical processing units to be used for GPU calculations).  Or, some nodes
might be available preferentially for different users than for others. For these
reasons, nodes are grouped into different collections.  Depending on the system you are
using, these collections of different nodes are called, either, _partitions_ or _queues_.  

On every cluster, however, there will be one to several nodes that are reserved not for
doing computation, but for allowing users to access the cluster.  These are called the
_login_ nodes or the _head_ nodes.  These nodes are _solely_ for logging in, light editing of
scripts, minor manipulation of directories, and scheduling and managing jobs.  They are absolutely _not_
for doing major computations.  For example, you should never login to the head node and immediately
start using it, in an interactive `bash` session to, say, sort BAM files or run `bwa mem`
to do alignments.  Running commands that require a lot of computation, or a lot of
input and output from the disk, on the login nodes is an egregious
_faux pas_ of cluster computing.  Doing so can
negatively impact the ability of other users to login or otherwise get their work done.  Therefore,
never do it!  All of your hardcore computation on a cluster _has_ to be done in a scheduled manner on
a _compute node_.  We will show how to do that shortly, but first we will talk about why.

## Cluster computing and the job scheduler

When you do work, or stream a video, or surf the web on your laptop computer, there are numerous
different computer processes running, to make sure that your computer keeps working and doing what it
is supposed to be doing.  In the case of your laptop, the operating system, itself, orchestrates
all these different processes, making sure that each one is given some compute time on your
laptop in order to get its work done.  Your laptop's operating system has a fair bit
of flexibility in how it allocates resources to these different processes: it has multiple
cores to assign different processes to, _and_ it
allows multiple processes to run on a single core, alternating between these different processes over
different _cycles_ of the central processing unit.  Things work differently
on a shared resource like an HPCC. The fundamental problem of cluster computing is basically
this: lots of people want to use the cluster to run big jobs, but the cluster does not
run like a single computer.

The cluster is not happy to give lots of different jobs
from lots of different users a chance to all run on the same core, sharing time by dividing up cycles.
When a user wants to use the computational resources of an HPCC,
she cannot just start a job and be confident that it will launch immediately and be granted
at least a few CPU cycles every now and again.  Rather, on an HPCC, every _job_ that is submitted
by a user will be assigned to a dedicated core (or several cores, if requested, and granted)
with a dedicated amount of memory.
If a core is not available for use, the job "gets in line" where it sits and waits (doing nothing) until a core
(with sufficient associated resources, like RAM memory) becomes available.  When such a core
becomes available in the cluster, the job gets launched on it.  All of this is orchestrated by the job scheduler,
of which SLURM is an example.  

In this computing model, a job, once it is launched, ties up the core and the memory
that has been allocated to it until the job is finished.  While that job is running, no one
else's jobs or processes can run on the core or share the RAM memory that was allocated to the job.
For this reason, the job scheduler, needs to know, _ahead of time_ how long each job might run and
what resources will be required during that time.  A simple contrived example illustrates things easily:
imagine that Joe and Cheryl each have 1000 separate jobs to run.  Each of Cheryl's jobs involves running
a machine-learning algorithm to identify seabirds in high-resolution, aerial images of the ocean, and
takes only about 20 minutes running on a single core.  Each of Joe's jobs, on the other hand, involves mapping billions of 
sequencing reads, a task which requires about 36 hours when run on a single core.
If their cluster has only 640 cores, and Joe submits his jobs first,
then, if the job scheduler were naive, it might put all of his jobs in line first, requiring some 50 or 60 hours
before the first of Cheryl's jobs even runs. This would be a huge buzz kill for Cheryl.
However, if Cheryl and Joe both have to provide estimates to the scheduler of how
long their jobs will run, the scheduler can make more equitable decisions, starting a few of Joe's jobs, but retaining
many more cores for Cheryl's jobs, each of which runs much faster.

Thus, when you want to run any jobs on a cluster, you must provide an estimate of the resources
that the job will require.  The three main axes upon which these resources are measured are:

1. The number of cores the job will require.
2. The maximum amount of RAM (memory) the job will require.
3. The amount of time for which the job will run.  

Requests for large amounts of resources for long periods of time generally take longer to start.
There are two main reasons for this: either 1) the scheduler does not want to launch too many
long-duration, high-memory jobs because it anticipates other users will want to use resources
down the road and no single user should tie up the compute resources
for too long; or 2) there are so many jobs running on myriad nodes and cores, that only
infrequently do nodes with sufficient numbers of cores and RAM come available to start
the new jobs.  

The second reason is a particular bane of new cluster users who unwittingly request more resources
than actually exist (i.e. 52 cores, when no single node has more than 32, or 50 Gb of RAM when no single
node has more than 48 Gb).  Unfortunately (or, perhaps comically, if you have a sick sense of
humor), most job schedulers will not notify you of this sort of transgression.
Rather, your job will just sit in line waiting to be launched, but it never will be, because sufficient
resources never become available!  

It is worth noting that regardless of whether reason 1 or reason 2 is the dominant cause influencing
how long it takes to start a job, asking for fewer resources for less time will generally allow your
jobs to start faster.  Particularly because of reason #2, however, breaking your jobs down (if possible) into
small chunks that will run relatively quickly on a single core with low RAM needs can render many more
opportunities for your jobs to start, letting you tap into resources that are not often fully utilized
in a cluster.  Since I started working on large cluster in which it took a long time to start a job
that required all or most of the cores on a single node, but in which there were many nodes
harboring a few cores that were not being used, I tend to endorse this approach...

Since the requested resources for a job play such a large role in wait times for jobs to start,
you might wonder why people don't intentionally underestimate the resources they request for their
jobs.  The answer is simple:  the job scheduler is a highly efficient and completely dispassionate
manager.  If you requested 2 hours for your job, but your job has not finished in that amount of time,
the job scheduler will waste no time hemming and hawing or having an emotional struggle with itself
about whether it should stop your job.  No, at 2 hours and 0.2 seconds it WILL kill your job, regardless
of whether it is just about to finish, or not.  Similarly, if you requested 4 Gb or RAM, but five hours into
your job, the program you are running ends up using 5 Gb or RAM to store a large chunk of data, your
job WILL be killed, immediately.  

Thus, it is best to be able to accurately estimate the time and resources a job will
require. You always want to request more time and resources than your job will
actually need, but not too much more.  A large part of getting good at computing
in a shared cluster resource is gaining experience in predicting how long different jobs will
run, and how much RAM they will require. Later we will describe how the records of your
jobs, stored by the job scheduler, can be accessed and organized to aid in predicting
the resource demand of future jobs.  

## Learning about the cluster resources and getting a shell on a compute node

Requests for resources, and for _information_ about the computing cluster, are made to the job scheduler
using a few basic commands.  As said, we will focus on the commands available in a SLURM-based system.
In a later section, (after a discussion of installing software that you might need on your cluster)
we will more fully cover the commands used to _launch_, _schedule_, and manage jobs.  Here
we will first explore the SLURM commands that
we can use to "get to know" our cluster, and we will leave this section seeing how
(and why) you should get resources on a compute node on your cluster.

All SLURM commands begin with an `s`, and all SLURM systems support the `sinfo` command
that gives you information about the cluster's nodes and their status (whether they are currently
running jobs or not.)  On your cluster, `man sinfo` will tell you about this command.
On the `Sedna` cluster, which just got installed and therefore does not
have many users, we see:
```sh
% sinfo
PARTITION AVAIL  TIMELIMIT  NODES  STATE NODELIST
nodes*       up   infinite     28   idle node[01-28]
himem        up   infinite      1  alloc himem01
himem        up   infinite      2   idle himem[02-03]
```
which tells us that there are two _partitions_ (collection of nodes)
named `nodes` and `himem`.  The `himem` partition has one node which is
currently allocated to a job (`STATE` = `alloc`), and two more that
are not currently allocated to jobs. The `himem` partition holds machines
with lots of RAM memory for tasks like sequence assembly.  It also has 28 compute nodes in the 
nodes partition that are free.  This is a very small cluster.

If you did the same command on SUMMIT you get many more lines of output.  There
are many more different partitions, and there is a lot of information about how many
nodes are in each:
```sh
% sinfo
PARTITION        AVAIL  TIMELIMIT  NODES  STATE NODELIST
shas*               up 1-00:00:00      2 drain* shas[0136-0137]
shas*               up 1-00:00:00      2  down* shas[0404,0506]
shas*               up 1-00:00:00      1  drain shas0101
shas*               up 1-00:00:00      3   resv shas[0102,0521,0853]
shas*               up 1-00:00:00     74    mix shas[0125,0130,0133,0138,0141,0149,0156,0158,0218,0222,0229,0236-0237,0240-0241,0243,0246,0255,0303,0311,0314,0322,0335,0337,0341,0343,0351,0357,0402,0411,0413,0415-0416,0418,0423,0428,0432-0433,0435-0436,0440,0452,0455-0456,0459,0501,0504,0514,0522-0524,0526-0527,0556,0608,0611-0613,0615-0616,0631,0637,0801,0810-0811,0815,0834-0835,0850,0855,0907-0909,0921]
shas*               up 1-00:00:00    359  alloc shas[0103-0124,0126-0129,0131-0132,0134-0135,0139-0140,0142-0148,0150-0155,0157,0159-0160,0201-0217,0219-0221,0223-0225,0227-0228,0230-0235,0238-0239,0242,0247-0254,0256-0260,0301-0302,0304-0310,0312-0313,0315-0321,0323-0334,0336,0338-0340,0342,0344-0350,0352-0356,0358-0360,0401,0405-0410,0412,0414,0417,0419-0422,0424-0427,0429-0431,0434,0437-0439,0442-0451,0453-0454,0457-0458,0460,0502-0503,0505,0507-0513,0515-0520,0525,0528-0555,0560,0605-0607,0609,0614,0617-0630,0632-0636,0638-0650,0652-0664,0802-0809,0812-0814,0816-0833,0836-0849,0851-0852,0854,0856-0860,0901-0906,0910-0913,0915-0920,0922-0932]
shas*               up 1-00:00:00     11   idle shas[0226,0244-0245,0403,0441,0557-0559,0610,0651,0914]
shas-testing        up   infinite      2 drain* shas[0136-0137]
shas-testing        up   infinite      2  down* shas[0404,0506]
shas-testing        up   infinite      1  drain shas0101
shas-testing        up   infinite      3   resv shas[0102,0521,0853]
shas-testing        up   infinite     74    mix shas[0125,0130,0133,0138,0141,0149,0156,0158,0218,0222,0229,0236-0237,0240-0241,0243,0246,0255,0303,0311,0314,0322,0335,0337,0341,0343,0351,0357,0402,0411,0413,0415-0416,0418,0423,0428,0432-0433,0435-0436,0440,0452,0455-0456,0459,0501,0504,0514,0522-0524,0526-0527,0556,0608,0611-0613,0615-0616,0631,0637,0801,0810-0811,0815,0834-0835,0850,0855,0907-0909,0921]
shas-testing        up   infinite    359  alloc shas[0103-0124,0126-0129,0131-0132,0134-0135,0139-0140,0142-0148,0150-0155,0157,0159-0160,0201-0217,0219-0221,0223-0225,0227-0228,0230-0235,0238-0239,0242,0247-0254,0256-0260,0301-0302,0304-0310,0312-0313,0315-0321,0323-0334,0336,0338-0340,0342,0344-0350,0352-0356,0358-0360,0401,0405-0410,0412,0414,0417,0419-0422,0424-0427,0429-0431,0434,0437-0439,0442-0451,0453-0454,0457-0458,0460,0502-0503,0505,0507-0513,0515-0520,0525,0528-0555,0560,0605-0607,0609,0614,0617-0630,0632-0636,0638-0650,0652-0664,0802-0809,0812-0814,0816-0833,0836-0849,0851-0852,0854,0856-0860,0901-0906,0910-0913,0915-0920,0922-0932]
shas-testing        up   infinite     11   idle shas[0226,0244-0245,0403,0441,0557-0559,0610,0651,0914]
shas-interactive    up   infinite      2 drain* shas[0136-0137]
shas-interactive    up   infinite      2  down* shas[0404,0506]
shas-interactive    up   infinite      1  drain shas0101
shas-interactive    up   infinite      3   resv shas[0102,0521,0853]
shas-interactive    up   infinite     74    mix shas[0125,0130,0133,0138,0141,0149,0156,0158,0218,0222,0229,0236-0237,0240-0241,0243,0246,0255,0303,0311,0314,0322,0335,0337,0341,0343,0351,0357,0402,0411,0413,0415-0416,0418,0423,0428,0432-0433,0435-0436,0440,0452,0455-0456,0459,0501,0504,0514,0522-0524,0526-0527,0556,0608,0611-0613,0615-0616,0631,0637,0801,0810-0811,0815,0834-0835,0850,0855,0907-0909,0921]
shas-interactive    up   infinite    359  alloc shas[0103-0124,0126-0129,0131-0132,0134-0135,0139-0140,0142-0148,0150-0155,0157,0159-0160,0201-0217,0219-0221,0223-0225,0227-0228,0230-0235,0238-0239,0242,0247-0254,0256-0260,0301-0302,0304-0310,0312-0313,0315-0321,0323-0334,0336,0338-0340,0342,0344-0350,0352-0356,0358-0360,0401,0405-0410,0412,0414,0417,0419-0422,0424-0427,0429-0431,0434,0437-0439,0442-0451,0453-0454,0457-0458,0460,0502-0503,0505,0507-0513,0515-0520,0525,0528-0555,0560,0605-0607,0609,0614,0617-0630,0632-0636,0638-0650,0652-0664,0802-0809,0812-0814,0816-0833,0836-0849,0851-0852,0854,0856-0860,0901-0906,0910-0913,0915-0920,0922-0932]
shas-interactive    up   infinite     11   idle shas[0226,0244-0245,0403,0441,0557-0559,0610,0651,0914]
sgpu                up 1-00:00:00      1   resv sgpu0501
sgpu                up 1-00:00:00      1  alloc sgpu0502
sgpu                up 1-00:00:00      9   idle sgpu[0101-0102,0201-0202,0301-0302,0401-0402,0801]
sgpu-testing        up   infinite      1   resv sgpu0501
sgpu-testing        up   infinite      1  alloc sgpu0502
sgpu-testing        up   infinite      9   idle sgpu[0101-0102,0201-0202,0301-0302,0401-0402,0801]
sknl                up 1-00:00:00      1  drain sknl0710
sknl                up 1-00:00:00      1   resv sknl0706
sknl                up 1-00:00:00     18  alloc sknl[0701-0705,0707-0709,0711-0720]
sknl-testing        up   infinite      1  drain sknl0710
sknl-testing        up   infinite      1   resv sknl0706
sknl-testing        up   infinite     18  alloc sknl[0701-0705,0707-0709,0711-0720]
smem                up 7-00:00:00      1   drng smem0201
smem                up 7-00:00:00      4  alloc smem[0101,0301,0401,0501]
ssky                up 1-00:00:00      1   drng ssky0944
ssky                up 1-00:00:00      1    mix ssky0952
ssky                up 1-00:00:00      3  alloc ssky[0942-0943,0951]
ssky-preemptable    up 1-00:00:00      1   drng ssky0944
ssky-preemptable    up 1-00:00:00      1    mix ssky0952
ssky-preemptable    up 1-00:00:00      9  alloc ssky[0933-0934,0937-0940,0942-0943,0951]
ssky-preemptable    up 1-00:00:00      9   idle ssky[0935-0936,0941,0945-0950]
ssky-ucb-aos        up 7-00:00:00      6  alloc ssky[0933-0934,0937-0940]
ssky-ucb-aos        up 7-00:00:00      3   idle ssky[0935-0936,0941]
ssky-csu-mbp        up 7-00:00:00      1   idle ssky0945
ssky-csu-asb        up 7-00:00:00      1   idle ssky0946
ssky-csu-rsp        up 7-00:00:00      4   idle ssky[0947-0950]
```

Yikes!  That is a lot of info.  The numbers that you see on the ends of the lines there
are node numbers.

If you wanted to see information about each node in the `shas` partition, you could
print long information for each node  like this:
```sh
% sinfo -l -N
```
On Summit, that creates almost 1500 lines of output.  Some nodes are listed several times
because they belong to different partitions.  To look at results for just the standard
parition (`shas`) you can use
```sh
% sinfo -l -n -p shas
```
Try that command.  (Or try a similar command with an appropriate partition name on your
own cluster.)  If you want to see explicitly how many cores are available vs allocated
on each node, how much total memory each node has, and how much of that total
memory is free, in that partition you can do:
```sh
% sinfo -N -p shas -O nodelist,cpusstate,memory,allocmem,freemem
```
The top part of that output looks like:
```
NODELIST            CPUS(A/I/O/T)       MEMORY              ALLOCMEM            FREE_MEM            
shas0101            0/0/24/24           116368              0                   125156              
shas0102            0/24/0/24           116368              0                   112325              
shas0103            24/0/0/24           116368              116352              87228               
shas0104            24/0/0/24           116368              116352              80769  
```
This says `shas0101` has 24 CPUs that are _Out_ (not functional at this point). 
`shas0102`, on the other hand, has 24 CPUs that are _Idle_, while `shas0103` has
24 CPUs that are allocated, and so forth. (In our parlance here, 
CPU is being used to mean "core").  All of the nodes have
116 Gb of memory total. Most of them have about that much memory allocated to
the jobs they are running.  

We can throw down some `awk` to count the total number of available cores
(and the total number of all the cores):
```sh
% sinfo -N -p shas -O  nodelist,cpusstate | awk -F"/" '{avail+=$2; tots+=$4} END {print "Out of", tots, "cores, there are", avail, "available"}' 
Out of 10848 cores, there are 331 available
```
That could explain why it can be hard to get time on the supercomputer: only about 3% of the cores in the system
are idle, waiting for jobs to go on them.

If you want to see how many jobs are in line, waiting to be launched, you can use the
`squeue` command.  Simply issuing the command `squeue` will give a (very long)
list of all jobs that are either currently running or are in the queue,
waiting to be launched. This is worth doing in order to see how many 
different people are using the resources.  The output can be filtered to just PENDING
or RUNNING jobs using the `-t` option. So,
```sh
squeue -t PENDING
```
lists all jobs waiting to be launched.  If you wanted to see jobs that a particular
user (like yourself) has running or pending, you can use the `-u` option. For example,
```sh
squeue -u eriq@colostate.edu
```
In fact that is such a worthwhile command that it is worth creating an alias
for it by adding a line such as the following to your `~/.bashrc`:
```sh
alias myjobs='squeue -u eriq@colostate.edu'
```
Then, typing `myjobs` shows all of the jobs that you have running, or waiting to be launched
on the cluster.






## Activating/Installing software

### Modules 

This is if your sys admin has made it easy.

### Miniconda

This is how one will probably want to do it

#### Testing this on Summit

I just want to quickly try this:
```sh
ssh eriq@colostate.edu@login.rc.colorado.edu

# get on compile nodes
ssh scompile

# I checked modules and found no samtools, bcftools, etc.

# Now install miniconda
mkdir conda_install
cd conda_install/
wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh
chmod u+x Miniconda3-latest-Linux-x86_64.sh 
./Miniconda3-latest-Linux-x86_64.sh 

# then you follow the prompts and agree to the license and the 
# default install location.

## NOTE: Might want to install to a different location if there
## are serious caps on hard disk usage in home directory..

source ~/.bashrc

# after that I have it!
(base) [eriq@colostate.edu@shas0136 conda_install]$
```

Now, let's see if we can get samtools.  Just google "samtools conda" to
get an idea of how to do it:
```sh
conda install -c bioconda samtools
```
AFter that, it just works! Cool!
```sh
(base) [eriq@colostate.edu@shas0136 ~]$ samtools

Program: samtools (Tools for alignments in the SAM format)
Version: 1.9 (using htslib 1.9)

Usage:   samtools <command> [options]

Commands:
  -- Indexing
     dict           create a sequence dictionary file
     faidx          index/extract FASTA
     fqidx          index/extract FASTQ
     index          index alignment

...
```

All right! That is amazing.  Next steps:

1. Tell students about establishing different environments.
2. Learn about how to make a minimal environment for a project and how to 
record that and be able to distribute/propagate it.

Along those lines, I want to see if, when I install samtools into a new environment,
it re-downloads it or not...
```sh
conda create --name quick-test
conda activate quick-test

# i also made an environment in a specified directory (you
# could put these within a project directory)
conda create --prefix ./test-envs-dir 
conda activate ./test-envs-dir

# now, let's install bcftools there
conda install -c bioconda bcftools

# note that it doesn't re-download the dependencies, as far as I can tell.
conda activate base
bcftools # not found in environment base

conda activate ./test-envs-dir
bcftools  # it is found in this environment.  Cool.

conda activate quick-test
bcftools  # it ain't here
```
Now, after that, bcftools is in ./test-envs-dir/bcftools

So, what if we install it into another environment.  Does it symlink it?
```sh
conda activate base
conda install -c bioconda bcftools
bcftools

# whoa! That errored out!
bcftools: error while loading shared libraries: libcrypto.so.1.0.0: cannot open shared object file: No such file or directory

# that is a serious problem.  

# Can I get it in my other environment?
conda activate quick-test
conda install -c bioconda bcftools
bcftools

# that totally works, but it still doesn't in base...

# so, what if we add samtools to our other environments?
# that works fine.
```

But, samtools/bcftools dependency issues are a known problem:  https://github.com/sunbeam-labs/sunbeam/issues/181
Basically they rely on different versions of some ssh libs.  

Note that installing bcftools first things work.  But what if we make another environment
and install samtools first again?
```sh
conda create --name samtools-first
conda activate samtools-first
conda install -c bioconda samtools  # this didn't download anything new
conda install -c bioconda bcftools

# BOOM! THIS CREATES A FAIL.  SO, YOU GOTTA INSTALL BCFTOOLS
# FIRST.  FAR OUT.
```

### Exporting environments

Looks like we should be able to do this.  Let's do the one that works:
```sh
(quick-test) [~]--% conda env export > quick-test-env.yml

(quick-test) [~]--% cat quick-test-env.yml 
name: quick-test
channels:
  - bioconda
  - defaults
dependencies:
  - _libgcc_mutex=0.1=main
  - bcftools=1.9=ha228f0b_4
  - bzip2=1.0.8=h7b6447c_0
  - ca-certificates=2019.5.15=1
  - curl=7.65.3=hbc83047_0
  - htslib=1.9=ha228f0b_7
  - krb5=1.16.1=h173b8e3_7
  - libcurl=7.65.3=h20c2e04_0
  - libdeflate=1.0=h14c3975_1
  - libedit=3.1.20181209=hc058e9b_0
  - libgcc-ng=9.1.0=hdf63c60_0
  - libssh2=1.8.2=h1ba5d50_0
  - libstdcxx-ng=9.1.0=hdf63c60_0
  - ncurses=6.1=he6710b0_1
  - openssl=1.1.1c=h7b6447c_1
  - samtools=1.9=h10a08f8_12
  - tk=8.6.8=hbc83047_0
  - xz=5.2.4=h14c3975_4
  - zlib=1.2.11=h7b6447c_3
prefix: /home/eriq@colostate.edu/miniconda3/envs/quick-test


# OK, that is cool.  Now, if we wanted to email that to someone,
# we could, and then they could do this:
conda env create --name dupie-quick -f quick-test-env.yml 

# that environment then has samtools and bcftools

# note that it probably would try to name it quick-test if we didn't
# pass in the name there...

```

## Boneyard







This is a variant of rsync that let's you sync stuff up to google drive.  It might be a better
solution than rcp for getting stuff onto and off of google drive.  Here is a link:
[https://rclone.org/](https://rclone.org/).  I need to evaluate it.  It might also be a good way
to backup some of my workstuff on my laptop to Google Drive (and maybe also for other people to create replicas and have a decent backup if they have unlimited Google Drive storage).


I got this working.  It is important to set your own OAuth client ID:
[https://forum.rclone.org/t/very-slow-sync-to-google-drive/6903](https://forum.rclone.org/t/very-slow-sync-to-google-drive/6903)

After that I did like this:
```
rclone sync -vv --tpslimit 10 --fast-list Otsh_v1.0_genomic.fna  gdrive-rclone:spoogee-spoogee
```
which did 2 Gb of fasta into the spoogee-spoogee directory pretty quickly.

But, with something that has lots of files, it took longer:
```
# this is only about 100 Mb but took a long time
rclone copy -P --tpslimit 10 --fast-list  rubias  gdrive-rclone:rubias
```
However, once that is done, you can sync it and it finds that parts that have changed pretty quickly.

it appears to do that by file modification times:
```sh
2019-04-19 23:21 /Otsh_v1.0/--% rclone sync -vv --tpslimit 10 --fast-list Otsh_v1.0_genomic.fna  gdrive-rclone:spoogee-spoogee
2019/04/19 23:21:36 DEBUG : rclone: Version "v1.47.0" starting with parameters ["rclone" "sync" "-vv" "--tpslimit" "10" "--fast-list" "Otsh_v1.0_genomic.fna" "gdrive-rclone:spoogee-spoogee"]
2019/04/19 23:21:36 DEBUG : Using config file from "/Users/eriq/.config/rclone/rclone.conf"
2019/04/19 23:21:36 INFO  : Starting HTTP transaction limiter: max 10 transactions/s with burst 1
2019/04/19 23:21:37 DEBUG : GCF_002872995.1_Otsh_v1.0_genomic.gff.gz: Excluded
2019/04/19 23:21:37 DEBUG : Otsh_v1.0_genomic.dict: Excluded
2019/04/19 23:21:37 DEBUG : Otsh_v1.0_genomic.fna.amb: Excluded
2019/04/19 23:21:37 DEBUG : Otsh_v1.0_genomic.fna.ann: Excluded
2019/04/19 23:21:37 DEBUG : Otsh_v1.0_genomic.fna.bwt: Excluded
2019/04/19 23:21:37 DEBUG : Otsh_v1.0_genomic.fna.fai: Excluded
2019/04/19 23:21:37 DEBUG : Otsh_v1.0_genomic.fna.pac: Excluded
2019/04/19 23:21:37 DEBUG : Otsh_v1.0_genomic.fna.sa: Excluded
2019/04/19 23:21:37 INFO  : Google drive root 'spoogee-spoogee': Waiting for checks to finish
2019/04/19 23:21:37 DEBUG : Otsh_v1.0_genomic.fna: Size and modification time the same (differ by 0s, within tolerance 1s)
2019/04/19 23:21:37 DEBUG : Otsh_v1.0_genomic.fna: Unchanged skipping
2019/04/19 23:21:37 INFO  : Google drive root 'spoogee-spoogee': Waiting for transfers to finish
2019/04/19 23:21:37 INFO  : Waiting for deletions to finish
2019/04/19 23:21:37 INFO  : 
Transferred:   	         0 / 0 Bytes, -, 0 Bytes/s, ETA -
Errors:                 0
Checks:                 1 / 1, 100%
Transferred:            0 / 0, -
Elapsed time:        1.3s

2019/04/19 23:21:37 DEBUG : 5 go routines active
2019/04/19 23:21:37 DEBUG : rclone: Version "v1.47.0" finishing with parameters ["rclone" "sync" "-vv" "--tpslimit" "10" "--fast-list" "Otsh_v1.0_genomic.fna" "gdrive-rclone:spoogee-spoogee"]
2
```

So, for moving big files around that might be a good way forward.  I will have to do a test with some big files.

And I need to test it with team drives so that multiple individuals can pull stuff off of the Bird Genoscape drive for example.

It would be nice to have safeguards so people don't trash stuff accidentally....

#### rclone on Hoffman

Their default install script expects sudo access to put it in /usr/local
but I don't on hoffman, obviously, so I just downloaded the the install script and edited
the section for Linux to look like this at the relevant part
```sh
case $OS in
  'linux')
    #binary
    cp rclone ~/bin/rclone.new
    chmod 755 ~/bin/rclone.new
    #chown root:root /usr/bin/rclone.new
    mv ~/bin/rclone.new ~/bin/rclone
    #manuals
    #mkdir -p /usr/local/share/man/man1
    #cp rclone.1 /usr/local/share/man/man1/
    #mandb
    ;;
```
I don't get man pages, but I get it in ~/bin no problem.

To set up the configuration, check where it belongs:
```sh
% rclone config file
Configuration file doesn't exist, but rclone will use this path:
/u/home/e/eriq/.config/rclone/rclone.conf
```
And then I just put my config file from my laptop on there.  I just pasted the stuff 
in whilst emacsing it.  Holy cow!  That is super easy.

Note that the config file is where you can also set default options like tpslimit and fast-list I think.

So, the OAuth stuff is all stored in that config file. And if you can set it up on one machine you can
go put it on any others that you want.  That is awesome.

When it was done, I tested it:
```sh
% rclone sync -vv  --drive-shared-with-me  gdrive-rclone:BaselinePaper  BaselinePaper_here
2019/04/29 14:49:24 DEBUG : rclone: Version "v1.47.0" starting with parameters ["rclone" "sync" "-vv" "--drive-shared-with-me" "gdrive-rclone:BaselinePaper" "BaselinePaper_here"]
2019/04/29 14:49:24 DEBUG : Using config file from "/u/home/e/eriq/.config/rclone/rclone.conf"
2019/04/29 14:49:25 INFO  : Local file system at /u/home/e/eriq/BaselinePaper_here: Waiting for checks to finish
2019/04/29 14:49:25 INFO  : Local file system at /u/home/e/eriq/BaselinePaper_here: Waiting for transfers to finish
2019/04/29 14:49:26 DEBUG : Local file system at /u/home/e/eriq/BaselinePaper_here: File to upload is small (41922 bytes), uploading instead of streaming
2019/04/29 14:49:26 DEBUG : BaselinePaper_Body.docx: Failed to pre-allocate: operation not supported
2019/04/29 14:49:26 INFO  : BaselinePaper_Body.docx: Copied (new)
2019/04/29 14:49:26 DEBUG : BaselinePaper_Body.docx: Updating size of doc after download to 41922
2019/04/29 14:49:26 INFO  : BaselinePaper_Body.docx: Copied (Rcat, new)
2019/04/29 14:49:27 DEBUG : Local file system at /u/home/e/eriq/BaselinePaper_here: File to upload is small (57172 bytes), uploading instead of streaming
2019/04/29 14:49:27 DEBUG : ResponseToReviewers_eca.docx: Failed to pre-allocate: operation not supported
2019/04/29 14:49:27 INFO  : ResponseToReviewers_eca.docx: Copied (new)
2019/04/29 14:49:27 DEBUG : ResponseToReviewers_eca.docx: Updating size of doc after download to 57172
2019/04/29 14:49:27 INFO  : ResponseToReviewers_eca.docx: Copied (Rcat, new)
2019/04/29 14:49:27 INFO  : Waiting for deletions to finish
2019/04/29 14:49:27 INFO  : 
Transferred:   	  193.543k / 193.543 kBytes, 100%, 79.377 kBytes/s, ETA 0s
Errors:                 0
Checks:                 0 / 0, -
Transferred:            4 / 4, 100%
Elapsed time:        2.4s

2019/04/29 14:49:27 DEBUG : 6 go routines active
2019/04/29 14:49:27 DEBUG : rclone: Version "v1.47.0" finishing with parameters ["rclone" "sync" "-vv" "--drive-shared-with-me" "gdrive-rclone:BaselinePaper" "BaselinePaper_here"]
```
That was fast and super solid.


#### Encrypt the config file

You can use `rclone config edit` to set a password for the config file.  Then it
encrypts that so no one is able to run wild if they just get that file.  You have to
provide your password to do any of the rclone commands.  If you want to see the
config file use `rclone config show`.  You could always copy that elsewhere, and then
re-encrypt it.








Here is some nice stuff for summarizing all the information from the different runs from the chinook-wgs project:
```sh
qacct -o eriq -b 09271925 -j ml | tidy-qacct
```

Explain scratch space and how clusters are configured with respect to storage, etc.

Strategies---break names up with consistent characters:

- dashes within population names
- underscores for different groups of chromosomes
- periods for catenating pairs of pops

etc.  Basically, it just makes it much easier to split things up
when the time comes.

## The Queue  (SLURM/SGE/UGE)

## Modules package

## Compiling programs without admin privileges

Inevitably you will want to use a piece of software that is not available as
a module or is not otherwise installed on they system.

Typically these software programs have a frightful web of dependencies.

Unix/Linux distros typically maintain all these dependencies as libraries or packages
that can be installed using a `rpm` or `yum`.  However, the simple "plug-and-play" approach
to using these programs requires have administrator privileges so that the software can
be installed in one of the (typically protected) paths in the root (like `/usr/bin`).

But, you can use these programs to install packages into your home directory.  Once you have done
that, you need to let your system know where to look for these packages when it needs them
(i.e., when running a program or _linking_ to it whilst compiling up a program that uses it
as a dependency.

Hoffman2 runs CentOS.  Turns out that CentOS uses `yum` as a package manager.

Let's see if we can install llvm using yum.

```sh
yum search all llvm # <- this got me to devtoolset-7-all.x86_64 : Package shipping all available toolsets.

# a little web searching made it look like llvm-toolset-7-5.0.1-4.el7.x86_64.rpm or devtoolset-7-llvm-7.0-5.el7.x86_64.rpm
# might be what we want.  The first is a dependency of the second...
mkdir ~/centos

```
Was using instructions at [https://stackoverflow.com/questions/36651091/how-to-install-packages-in-linux-centos-without-root-user-with-automatic-depen](https://stackoverflow.com/questions/36651091/how-to-install-packages-in-linux-centos-without-root-user-with-automatic-depen) 

Couldn't get yum downloader to download any packages.  The whole thing looked like it was going to
be a mess, so I thought I would try with miniconda.

I installed miniconda (python 2.7 version) into `/u/nobackup/kruegg/eriq/programs/miniconda/` and then did this:
```sh
# probably could have listed them all at once, but wanted to watch them go 
# one at a time...
conda install numpy
conda install scipy
conda install pandas
conda install numba

# those all ran great.

conda install pysnptools

# that one didn't find a match, but I found on the web that I should try:
conda install -c bioconda pysnptools 

# that worked!
```


Also we want to touch briefly on LD_PATH (linking failures---and note that libraries are often
named libxxx.a) and CPATH (for failure to find xxxx.h), etc.




## Job arrays


Quick note: Redefine IFS to break on TABs so you can have full commands in there.
This is super useful for parsing job-array COMMLINES files.  
```
IFS=$'\t\n'; BOP=($(echo boing | awk '{printf("first\tsecond\tthird that is long\tfourth\n");}')); IFS=$' \t\n';
```


Definitely mention the `eval` keyword in bash for when you want to print 
command lines with redirects.  

Show the routine for it, and develop a good approach to efficiently
orchestrating redos.  If you know the taskIDs of the ones that failed
then it is pretty easy to write an awk script that picks out the
commands and puts them in a new file.  Actually, it is probably
better to just cycle over the numbers and use the -t option
to launch each.  Then there is now changing the job-ids file.  

In fact, I am starting to think that the -t option is better than
putting it into the file.

Question: if you give something on the command line, does that override
the directive in the header of the file?  If so, then you don't even
need to change the file.  Note that using the qsub command line options
instead of the directives really opens up a lot of possibilities for
writing useful scripts that are flexible.  

Also use short names for the jobs and have a system for naming the
redos (append numbers so you know which round it is, too) 
possibly base the name on the ways things failed the first time.  Like,
`fsttf1` = "Fst run for things that failed due to time limits, 1". Or
structure things so that redos can just be done by invoking it with -t 
and the jobid.

## Writing stdout and stderr to files

This is always good to do.  Note that `stdbuf` is super useful here so that
things don't get buffered super long. (PCAngsd doesn't seem to write antyhing till
the end...)


## Breaking stuff down

It is probably worth talking about how problems can be broken down into
smaller ones.  Maybe give an example, and then say that we will be talking about
this for every step of the way in bioinformatic pipelines.

One thing to note---sometimes processes go awry for one reason or another.
When things are in smaller chunks it is not such a huge investment to
re-run it. (Unlike stuff that runs for two weeks before you realize that
it ain't working right).

