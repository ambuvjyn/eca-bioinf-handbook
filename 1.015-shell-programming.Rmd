
# Shell programming

In our first foray into Unix and the shell, we restricted ourselves mostly
to navigating the file system, handling files, and working with streams of data
(via redirection and pipes).  These are all crucial skills, but the bash shell
becomes truly powerful when we start to adopt it as a sort of programming language.
That's right, even though the functionality of bash is geared toward running jobs
and calling commands, it still exhibits most of the features expected in a programming
language, like variables, iteration and flow control.

We start this section by taking a look at a short bash program (typically
called a _script_) that the author wrote in order to efficiently download
(clone, really) repositories from GitHub that have been submitted by
students to GitHub Classroom.  The program is not long, but exhibits
many useful features of bash as a programming language. If you are reading
this, not in the context of a class with lectures, just go ahead and read
through it and see if you can figure out what is going on in each line
of the script.  Afterward, we will address many features of bash by
referencing different parts of the script.

The script, which happens to be stored in a file called `clone-classroom-repos.sh`
is printed below, with linenumbers, since we will
be referring back to specific sections of the script later.
```{sh, eval=FALSE, attr.source='.numberLines'}
#!/bin/bash

# define a function to print the usage or "help" for the script
function usage {
      echo Syntax:
      echo "  $(basename $0)  GH_Prefix  Repo_Prefix  Branch  Dir
      
      GH_Prefix: the URL of the GitHub site where the repository exists.
      Repo_Prefix: the prefix of the name of each repository to be cloned.
      Branch: the name of the branch to create and switch to in the repository,
         once the repo has been cloned.
      Dir: path to the directory (will be created if necessary) to clone all
         the repositories to.
         
   Example:
   
   	  $(basename $0)  https://github.com/CSU-con-gen-bioinformatics-2020  illumina-video-questions- erics-edits  /tmp/illumina-questions
      "
      echo
}

#  test for right number of required args.  If not, print usage message
if [ $# -ne 4 ]; then
    usage;
    exit 1;
fi

# copy positional parameters into other variables
GHP=$1
RP=$2
BRANCH=$3
DD=$4

# assign string with student GitHub handles into a variable
GHNAMES="AmandaCicchino
BrennaF
CaitlinWells
EllenMCampbell
FayDong
LibbyGH
NathanPhipps
RGCheek
Ronan17
abeulke
carolazari
cbossu
ccolumbu
elenacorrea
eriqande
jenleon07
kimhoke
kruegg
lauracgoetz
mdrod110
mgdesaix
raven-wings
seamus100
taylorbobowski
wcfunk"

# assign my GitHub username to the variable USER
USER=eriqande

# assign the current working directory to the variable RUNDIR
RUNDIR=$PWD

# make a new directory named whatever the user wanted for the output directory
mkdir -p $DD

# make variables to hold log and error file names
LOG=${PWD}/${RP}log
ERR=$LOG.stderr

# print the date/time when the process is starting
echo "STARTING at $(date)"

# make a clean slate. remove any files with the name
# of the error output file
rm -f $ERR

# cycle over the student GitHub names, and for each one *do*
# the commands that appear before the *done* keyword. Indenting
# is used to make it easier to read, but is not essential.
for L in $GHNAMES; do

    echo "Working on $L, starting at $(date)"  # print a progress line to stdout
    REPO=$GHP/${RP}$L     # combine variables into new variables that
    echo $REPO            # hold the URL for the repository to be
    DEST=$DD/$L           # cloned and the path where it should be cloned to
  
    # store the commands themselves into variables. Note the 
    # use of double quotes.
    CLONE_IT="git clone ${REPO/github.com/$USER@github.com} $DEST" 
    BRANCH_IT="git checkout -B $BRANCH"
    PUSH_IT="git push -u origin $BRANCH"
  
    
    # now, run those commands, chained together by exit-status-AND
    # operators (so it will stop if any one part fails), while
    # all the while appending error statements to the Error file. Run it
    # all within an "if" statement so you can deliver a report as to
    # whether the whole shebang succeeded or failed.
    if $CLONE_IT 2>> $ERR  && \
        cd $DEST && \
        $BRANCH_IT 2>> $ERR  && \
        $PUSH_IT 2>> $ERR  && \
        cd $RUNDIR   # at the very end make sure to return to the original working directory
    then
        echo "FULL SUCCESS $L"
    else
        echo "FAILURE SOMEWHERE WITHIN $L"
        cd $RUNDIR  # get back to the working directory from which the original command was run.
                    # so we are ready to handle the next student repo.
    fi
  
done  # signifies the end of the for loop we are cycling over
```

If my current working directory is where the script resides, I can run it
like this:
```sh
% ./clone-classroom-repos.sh 
```
And if I wanted to be fancy, I could put the script in a directory (like `~/bin` perhaps)
that I have included in my `PATH` variable.  In which case I could run it like:
```sh
% clone-classroom-repos.sh 
```
from anywhere on my computer.

When I run the script in any of those two ways, because I have not provided the
proper number of _arguments_ to the command, it returns a message telling me
what syntax is required to use it (i.e., its _usage syntax_):
```sh
% clone-classroom-repos.sh 
Syntax:
  clone-classroom-repos.sh  GH_Prefix  Repo_Prefix  Branch  Dir
      
      GH_Prefix: the URL of the GitHub site where the repository exists.
      Repo_Prefix: the prefix of the name of each repository to be cloned.
      Branch: the name of the branch to create and switch to in the repository,
         once the repo has been cloned.
      Dir: path to the directory (will be created if necessary) to clone all
         the repositories to.
         
   Example:
   
   	  clone-classroom-repos.sh  https://github.com/CSU-con-gen-bioinformatics-2020  illumina-video-questions- erics-edits  /tmp/illumina-questions
   	  
```

That is handy, and the code to do it exists in the script itself.  Looking at the output, how many
arguments do you think the script is expecting?


Now, if I wanted to clone all of the student GitHub repos associated with the `illumina-video-questions`
homework set, and then, once cloned, set up a new git _branch_ called `eric-edits` so that I can make
edits and/or comments and send those to students via a pull request, here is the command I would give
(remembering, again that the `%` signifies the command prompt, here): 
```sh
% clone-classroom-repos.sh  https://github.com/CSU-con-gen-bioinformatics-2020  illumina-video-questions- erics-edits  /tmp/illumina-questions
```

And when I do, I see output like this:
```
STARTING at Thu Feb 13 06:02:05 MST 2020
Working on AmandaCicchino, starting at Thu Feb 13 06:02:05 MST 2020
https://github.com/CSU-con-gen-bioinformatics-2020/illumina-video-questions-AmandaCicchino
Branch erics-edits set up to track remote branch erics-edits from origin.
FULL SUCCESS AmandaCicchino
Working on BrennaF, starting at Thu Feb 13 06:02:07 MST 2020
https://github.com/CSU-con-gen-bioinformatics-2020/illumina-video-questions-BrennaF
Branch erics-edits set up to track remote branch erics-edits from origin.
FULL SUCCESS BrennaF
Working on CaitlinWells, starting at Thu Feb 13 06:02:08 MST 2020
https://github.com/CSU-con-gen-bioinformatics-2020/illumina-video-questions-CaitlinWells
FAILURE SOMEWHERE WITHIN CaitlinWells
Working on EllenMCampbell, starting at Thu Feb 13 06:02:09 MST 2020
https://github.com/CSU-con-gen-bioinformatics-2020/illumina-video-questions-EllenMCampbell
Branch erics-edits set up to track remote branch erics-edits from origin.
FULL SUCCESS EllenMCampbell
Working on FayDong, starting at Thu Feb 13 06:02:10 MST 2020
https://github.com/CSU-con-gen-bioinformatics-2020/illumina-video-questions-FayDong
Branch erics-edits set up to track remote branch erics-edits from origin.
FULL SUCCESS FayDong
Working on LibbyGH, starting at Thu Feb 13 06:02:12 MST 2020
https://github.com/CSU-con-gen-bioinformatics-2020/illumina-video-questions-LibbyGH
Branch erics-edits set up to track remote branch erics-edits from origin.
FULL SUCCESS LibbyGH
Working on NathanPhipps, starting at Thu Feb 13 06:02:14 MST 2020
https://github.com/CSU-con-gen-bioinformatics-2020/illumina-video-questions-NathanPhipps
Branch erics-edits set up to track remote branch erics-edits from origin.
FULL SUCCESS NathanPhipps
Working on RGCheek, starting at Thu Feb 13 06:02:15 MST 2020
https://github.com/CSU-con-gen-bioinformatics-2020/illumina-video-questions-RGCheek
Branch erics-edits set up to track remote branch erics-edits from origin.
FULL SUCCESS RGCheek
Working on Ronan17, starting at Thu Feb 13 06:02:17 MST 2020
https://github.com/CSU-con-gen-bioinformatics-2020/illumina-video-questions-Ronan17
Branch erics-edits set up to track remote branch erics-edits from origin.
FULL SUCCESS Ronan17
Working on abeulke, starting at Thu Feb 13 06:02:19 MST 2020
https://github.com/CSU-con-gen-bioinformatics-2020/illumina-video-questions-abeulke
Branch erics-edits set up to track remote branch erics-edits from origin.
FULL SUCCESS abeulke
Working on carolazari, starting at Thu Feb 13 06:02:21 MST 2020
https://github.com/CSU-con-gen-bioinformatics-2020/illumina-video-questions-carolazari
Branch erics-edits set up to track remote branch erics-edits from origin.
FULL SUCCESS carolazari
Working on cbossu, starting at Thu Feb 13 06:02:23 MST 2020
https://github.com/CSU-con-gen-bioinformatics-2020/illumina-video-questions-cbossu
Branch erics-edits set up to track remote branch erics-edits from origin.
FULL SUCCESS cbossu
Working on ccolumbu, starting at Thu Feb 13 06:02:25 MST 2020
https://github.com/CSU-con-gen-bioinformatics-2020/illumina-video-questions-ccolumbu
Branch erics-edits set up to track remote branch erics-edits from origin.
FULL SUCCESS ccolumbu
Working on elenacorrea, starting at Thu Feb 13 06:02:26 MST 2020
https://github.com/CSU-con-gen-bioinformatics-2020/illumina-video-questions-elenacorrea
Branch erics-edits set up to track remote branch erics-edits from origin.
FULL SUCCESS elenacorrea
Working on eriqande, starting at Thu Feb 13 06:02:28 MST 2020
https://github.com/CSU-con-gen-bioinformatics-2020/illumina-video-questions-eriqande
Branch erics-edits set up to track remote branch erics-edits from origin.
FULL SUCCESS eriqande
Working on jenleon07, starting at Thu Feb 13 06:02:29 MST 2020
https://github.com/CSU-con-gen-bioinformatics-2020/illumina-video-questions-jenleon07
FAILURE SOMEWHERE WITHIN jenleon07
Working on kimhoke, starting at Thu Feb 13 06:02:30 MST 2020
https://github.com/CSU-con-gen-bioinformatics-2020/illumina-video-questions-kimhoke
FAILURE SOMEWHERE WITHIN kimhoke
Working on kruegg, starting at Thu Feb 13 06:02:30 MST 2020
https://github.com/CSU-con-gen-bioinformatics-2020/illumina-video-questions-kruegg
FAILURE SOMEWHERE WITHIN kruegg
Working on lauracgoetz, starting at Thu Feb 13 06:02:30 MST 2020
https://github.com/CSU-con-gen-bioinformatics-2020/illumina-video-questions-lauracgoetz
FAILURE SOMEWHERE WITHIN lauracgoetz
Working on mdrod110, starting at Thu Feb 13 06:02:31 MST 2020
https://github.com/CSU-con-gen-bioinformatics-2020/illumina-video-questions-mdrod110
Branch erics-edits set up to track remote branch erics-edits from origin.
FULL SUCCESS mdrod110
Working on mgdesaix, starting at Thu Feb 13 06:02:32 MST 2020
https://github.com/CSU-con-gen-bioinformatics-2020/illumina-video-questions-mgdesaix
Branch erics-edits set up to track remote branch erics-edits from origin.
FULL SUCCESS mgdesaix
Working on raven-wings, starting at Thu Feb 13 06:02:34 MST 2020
https://github.com/CSU-con-gen-bioinformatics-2020/illumina-video-questions-raven-wings
FAILURE SOMEWHERE WITHIN raven-wings
Working on seamus100, starting at Thu Feb 13 06:02:34 MST 2020
https://github.com/CSU-con-gen-bioinformatics-2020/illumina-video-questions-seamus100
Branch erics-edits set up to track remote branch erics-edits from origin.
FULL SUCCESS seamus100
Working on taylorbobowski, starting at Thu Feb 13 06:02:36 MST 2020
https://github.com/CSU-con-gen-bioinformatics-2020/illumina-video-questions-taylorbobowski
Branch erics-edits set up to track remote branch erics-edits from origin.
FULL SUCCESS taylorbobowski
Working on wcfunk, starting at Thu Feb 13 06:02:37 MST 2020
https://github.com/CSU-con-gen-bioinformatics-2020/illumina-video-questions-wcfunk
Branch erics-edits set up to track remote branch erics-edits from origin.
FULL SUCCESS wcfunk
```
From that report, it is clear that it takes about 1 to 2 seconds to handle each
repository.  If I were doing each repository by hand, (i.e. cloning and
branching through a GUI
interface like RStudio's) each repository would probably take me about 30 seconds
to a minute, with a lot of copying and pasting and chance for errors,
and I would have destroyed my wrists with all the repetitive tasks.  So, this
is a HUGE deal.

It is also easy to scan through the results and see, "Holy Moly! These are
some dedicated students!" Everyone has successfully submitted their homework repositories
(and thus we were `SUCCESS`-ful in cloning them), except for a handful
who were traveling or otherwise occupied and had warned me they wouldn't
be able to do the assignment.


When all is said and done, I have the following git repositories on my laptop which 
I can peruse at my leisure:
```sh
% ls /tmp/illumina-questions/
AmandaCicchino/ FayDong/        RGCheek/        carolazari/     elenacorrea/    mgdesaix/       wcfunk/
BrennaF/        LibbyGH/        Ronan17/        cbossu/         eriqande/       seamus100/
EllenMCampbell/ NathanPhipps/   abeulke/        ccolumbu/       mdrod110/       taylorbobowski/
```

Additionally, in the directory where I ran the command, I have a
file called `illumina-video-questions-log.stderr` that gives me a more detailed
report of things when they worked or failed.

If you are new to Unix, then the above script likely appears a bit daunting.
Our goal by the end of the chapter is to have described every little piece
of bash syntax needed, so that you will be able to read and understand the
above script. You will thus also be in a good position to start
writing your own scripts to automate tasks and analyses
on your computer.

We will start with an overview of the structure of a script and then
delve into specific areas of syntax.  For each area of syntax, we will
provide some examples, and then leave some openings for you, the reader,
to try your own hand at implementing each pattern that you see.

## The Structure of a Bash Script

A bash script is merely a text file that is a collection of different command lines, one
after the next, which the bash shell will run in sequence---one after
the other.  If you want to run the script, you must make sure you have set its
permissions to include execute permissions (i.e., `chmod ug+x script.sh`).  

It is important to point out however, that the bash programming syntax that
we will be describing in this chapter is not solely useful in the context
of scripts that are stored in files.  Rather, all the programming syntax can still
be used directly on the shell command line itself!  This means you can employ
all the little tricks you will learn in this chapter while directly "hacking away"
at the command line. In this context, it is worth noting that if you want to
write multiple distinct commands on a single line, _as if they were on separate lines_,
you can separate them with a semicolon, `;`. For example:
```{sh}
echo "Put this in a file! (and catenate it later...twice!)" > tmp.txt
cat tmp.txt
cat tmp.txt
```
Is equivalent to:
```{sh}
echo "Put this in a file! (and catenate it later...twice!)" > tmp.txt; cat tmp.txt; cat tmp.txt
```

Sometimes when you are writing a script, (or even working on the command line) you might want
a very long expression to be treated as being all part of the same command line, even though
you would like to break it up over multiple lines.  A backslash (`\`) immediately followed by
a line ending (i.e., the "return" key) has the effect of treating the lines that it separates
as all being on the same line.
```sh
# this:
clone-classroom-repos.sh  \
    https://github.com/CSU-con-gen-bioinformatics-2020  \
    illumina-video-questions- \
    erics-edits  \
    /tmp/illumina-questions

# is the same as this:
clone-classroom-repos.sh  https://github.com/CSU-con-gen-bioinformatics-2020  illumina-video-questions- erics-edits  /tmp/illumina-questions

```
Using backslashes (and indenting) in this way can sometimes dramatically improve readability of
your scripts.

You might also notice a number of lines or statements in the script above that start
with a `#`.  The `#` is known as a _comment character_.  When the bash interpreter is
reading the script, it _ignores_ the comment character _and anything following it_ until 
the _end of the line_.  This makes it quite convenient to pepper your scripts with
notes to yourselves or others that can be _extremely_ helpful when you come back
to a piece of code and are trying to remember what it does! Example:
```{sh, error=TRUE}
# this might report an error if there is no file
# named SillyRidiculous.what
ls -l SillyRidiculous.what
```
(Note: each line of the the _output_ shown above follows two `#` symbols.  This
is not commenting.  It is just the convention that the 'bookdown' package uses to signify that
what it is showing you is output, rather than input. No relation, really, to commenting...

In the `clone-classroom-repos.sh` script, listed above, on the very top line (line 1) you will see
a special statement that follows a `#` comment character.  This is one of the few cases you will
see when the contents after a comment character are _not_ ignored (the other place you will see this
is when preparing additional statements for schedulers for high-performance computing systems!). 
In this case the combination `#!` on the first line is telling Unix to get ready to learn how
to interpret the contents of the script:
```
#!/bin/bash
```
The part after the `#!` is just 
the path to the program `bash` that implements the bash shell.  It is telling Unix
how to run the script.  While it is common practice to put this top line on a script,
on most systems, if the line is absent, Unix will interpret the script using bash, anyway.

If you ever find yourself having a hard time remembering the order of those first two
symbols (i.e., is it `#!` or `!#`?), just remember that it is sometimes called
the _shebang_.  You know the first part should be a comment character so the line is treated
a little differently, but then that has to be followed by the "bang" which is `!`.  

### A bit more on `;` and `&`

Recall the semicolon: it provides a way to combine multiple commands on a single line.
In fact, when you think of putting multiple commands on different lines, you could
think of each one being followed by a semicolon.  Like this:
```sh
# this
echo one
echo two

# is the same as
echo one;
echo two;

# is the same as
echo one; echo two;
```
However, there is another character, beyond the semicolon, with which you might
follow commands.  It is the _single_ `&` symbol.  Thus,
you could use it like a semicolon, writing and executing this:
```sh
echo one & echo two &
```
But, if you do that on your Unix system, you should see some numbers and a report
about jobs, like this:
```
[1] 1007
[2] 1008
one
two
[1]-  Done                    echo one
[2]+  Done                    echo two
```
Whoa! What the heck is going on there?  The `&` symbol means, "run the command that
came before it, but don't bother waiting for it to be done before running the next one."
As a consequence of this, when you run a command followed by a `&`, the computer returns to you
the job ID numbers for the jobs that have been started, and when they are done, it
also tells you that the jobs that have completed. 

If you want to run multiple jobs on your own computer, the `&` syntax can be helpful.
But, most of the time as a bioinformatician, you will be vying with countless others
to run jobs on a large server or cluster.  In those cases there are more refined
systems for allocating jobs, and, as a consequence, you may rarely use the single `&`
syntax when working on a high performace computing system.

## Variables

When your goal is to script up repetitive tasks, one of the main ingredients to your
success is bash's ability to _assign_ _values_ to _variables_, and then later, retrieve
those values and replace a variable in your script with its value, a process
known as _variable substitution_.  Both _variable assignment_ and
_variable subtitution_ happen all over the `clone-classroom-repos.sh`
script, in lines like:
```sh
USER=eriqande
LOG=${PWD}/${RP}log
ERR=$LOG.stderr
```
We are going to break this down because it is of central importance.

### Assigning values to variables

The syntax to assign a value to a variable is, "put the variable on the left, follow it
with an equals sign **with absolutely no spaces around it**, and the put the value
on the right," like this:
```sh
VAR=value
HUNGRY="My cat, Oliver"
SWEET="A chocolately treat"
MY_FILE=/Users/eriq/Documents/git-repos/eca-bioinf-handbook/eca-bioinf-handbook.Rproj
lowercase_variables_work_too="oh yeah."
Or_even_MIXtures_of_cases=boing
```
Identify the variables and the values in the above. 

The names of variables must start with either an upper- or lowercase letter
or an underscore. After that initial character, valid variable names can
then include any combination of underscores, upper- and lowercase letters
and numerals.  

In the following, identify the variable names that are valid and those
that are not on each line.  After you have made your choices, paste all
these lines into your terminal to see which ones work and which do not.
```sh
vaRiAble=value
1_tough_cookie="hard to eat with false teeth"
_bring_it_on="A fine musical"
PLATE.FIFTEEN=/home/me/labwork/plate_15
```
Ha! That is a pretty easy task because syntax highlighter in 'bookdown' colors
variables differently than other parts of a script.  Oh well, you still get the point!

The value of the variable, on the other hand can be pretty much any string
(as long as it doesn't confuse the shell with characters like `&`, `;`, or `!`).
The shell typically understands that strings are delimited by whitespace, so, if
your string (value) should include multiple words separated by spaces, you must
enclose them in quotation marks:
```sh
NAME="Eric C. Anderson"
```
You can use either pairs of single quotes (`'this is single-quoted'`) or double
quotes (`"this is double-quoted"`), but the shell treats these very differently,
as we will see.  Most of the time, in bioinformatics, you will want to be using
double quotes.

If you want to include, in a variable's value, characters that have special meaning to the shell,
like `*`, `[`, `{`, `&`, and `;`, among others, you must enclose the string inside quotation
marks to assign it to your variable:
```sh
FOO="bar&grill"  # works
FOO=bar&grill    # won't work the way you want it to
```



### Accessing values from variables

This is called "variable substitution."  Remember, when you want something from someone, (or even
just from a variable) it might cost you some money.  Which is how you can
remember that you need to use the `$` to access values from variables. The `$` tells the
shell that you want the value of the variable, in a process called _variable substitution_. It is
called that, because if you write `$VAR`, somewhere in a command line, then 
the shell will happily go along and substitute the _value_ of the variable `$VAR` in place of the variable
itself, _after_ which the shell will evaluate the command line.

If you have a variable called `VAR`, the writing `$VAR` subtitutes its value on the command line.
The same occurs if you write `${VAR}`.  The latter is a little more formal, but is also, in
some sense a little more flexible, because it lets you append text immediately after the variable:
```{sh, error=TRUE}
FIRST_PART=oxy

# this works:
echo "I like the word ${FIRST_PART}moron"

# this doesn't
echo "I like the word $FIRST_PARTmoron"

# but this would
echo "Remove the stain with $FIRST_PART-clean"
```

In the case above that does not work, the shell is subtituting the value
of the variable `FIRST_PARTmoron` which actually does not exist, so
it substitutes nothing (and doesn't even give you an error).  This type
of mistake typically occurs when you forget the the underscore is part of
a valid variable name, like:
```sh
GENUS=Oncorhynhus
SPECIES=mykiss

cd $GENUS_$SPECIES  # Fail!

cd ${GENUS}_${SPECIES}  # Works!
```

**Now it is your turn**: save your three favorite foods into
the variables ONE, TWO, and THREE, and then use the `echo` command
to print `My three favorite foods are...` where you include
those foods via variable substitution:
```

```
Are we starting to feel the power of Unix scripting yet?

### What does the shell do with the value substituted for a variable?

This is a great question, and it gets at the heart of why Unix is so powerful
for scripting.  Recall that variable substitution occurs before command evaluation.
So, basically, after variable substitution, the shell has a command line that includes
the values instead of the variables.  Then it just evaluates that command line.  So, what
happens to the values that have been substituted for the variables depends on what context
they appear in, in the command line!

Follow along with this example:
```sh
# Start by assigning to DIR the absolute path of a directory you often go to
# Note, you should use a path from your own computer!
DIR=/Users/eriq/Documents/git-repos/eca-bioinf-handbook

# Now, note that we can do different things with that variable
# depending on how/where we put it in a command line.

# print it
echo $DIR

# list its contents
ls $DIR

# from your home directory (reached with `cd` and nothing after it)
# you can go directly to DIR like so:
cd
cd $DIR

# If you just put $DIR on the command line by itself, the shell
# interprets it as a command, and tries to execute it, which give an error:
$DIR

# On the other hand, if you wanted to make a new variable:
GODIR="cd $DIR"

# then, that would work as a command on its own:
cd
$GODIR
```
Oh! Now I am getting excited.  Notice that in the `clone-classroom-repos.sh` script I
did this quite a bit, making a few different command lines...
```sh
    # store the commands themselves into variables. Note the 
    # use of double quotes.
    CLONE_IT="git clone ${REPO/github.com/$USER@github.com} $DEST" 
    BRANCH_IT="git checkout -B $BRANCH"
    PUSH_IT="git push -u origin $BRANCH"
```
...that I would then call later:
```sh
    $CLONE_IT 2>> $ERR  && \
        cd $DEST && \
        $BRANCH_IT 2>> $ERR  && \
        $PUSH_IT 2>> $ERR  && \
        cd $RUNDIR
```

### Double and Single Quotation Marks and Variable Substitution

Quite often you will want to save a value to a variable that, itself,
includes other variables.  In other words, you want to do variable
subtition on the value you are assigning to the variable.  Double quote
let you do this: variable substition will proceed within double quotes:
```{sh}
FOO=sandwiches
BAR="I like $FOO"
echo $BAR
```

However, inside single quotes, variable subtitution will not occur:
```{sh}
FOO=sandwiches
BAR='I like $FOO'
echo $BAR
```

Each behavior has its uses, but most of the time, as I said, you will be wanting to use
double quotes.

**Now it is your turn**: Save three pairs of foods that you like (for example,
"cookies & cream" or "bananas & walnuts") into
three variables, `PAIR_ONE`, `PAIR_TWO`, and `PAIR_THREE`.  Then combine those into
a variable called `SENTENCE` and print it with `echo`, so that the result looks something
like: "I like cookies & cream, and bananas & walnuts, and rooibos and milk."
```

```

### One useful, fancy, variable-substitution method

Bash is full of fancy variable-substitution embellishments.  One that
I use all the time replaces strings in a variable with other strings.
Check this out:
```{sh}
FILE=my_picture.jpg
echo $FILE
echo ${FILE/jpg/png}
echo ${FILE/my/your}
```
That turns out to be some powerful stuff.



## Evaluate a command and substitute the result on the command line

Sometimes what you want to put on a command line isn't just a variable
you have previously defined but rather the result of a command that
is executed.  We see this in `clone-classroom-repos.sh` around line 75:
```sh
echo "STARTING at $(date)"
```
In general, if you put a command inside a `$()`, like `$(command)` it means take the output of
the command and insert it into the command line.

You can even assign the result to a variable, like `RESULT=$(command)`.

For example, try this:
```sh
# what do you think this is doing?
HOME_LIST=$(ls -l ~)

# what about this?
echo $HOME_LIST
```
Whoa! What happened to all my carriage returns?  The results gets put onto the command line and
parsed there.  The command line parser sometimes treats line endings as just more whitespace,
and it converts all runs of whitespace to a single space...

## Grouping/Collecting output from multiple commands

`( )`

## Advanced repetition

I want to get constructs like `{1..20}` and `{csv,pdf,jpg}` in here too.

## Variables

## looping


## Further reading

An excellent chapter on the development of Unix [@RaymondArtUNIXProgramming2003]

## reading files line by line

This is handy.  Note the line can be broken into a shell array:
```sh
cat bwa-run-list.txt straggler-bwa-run-list.txt | while read -r line; do 
  A=($line); 
  file=${A[1]}; 
  num=${A[2]}; 
  du -h bam-slices/$file/${num}-sorted.bam;  
done

2.3G	bam-slices/chinook_Battle.Creek.Sacramento.River_Schluter_GBC_001_CH1-2011_Male/0001-sorted.bam
2.2G	bam-slices/chinook_Battle.Creek.Sacramento.River_Schluter_GBC_001_CH1-2011_Male/0002-sorted.bam
2.2G	bam-slices/chinook_Battle.Creek.Sacramento.River_Schluter_GBC_001_CH1-2011_Male/0003-sorted.bam
2.3G	bam-slices/chinook_Battle.Creek.Sacramento.River_Schluter_GBC_001_CH1-2011_Male/0004-sorted.bam
2.2G	bam-slices/chinook_Battle.Creek.Sacramento.River_Schluter_GBC_001_CH1-2011_Male/0005-sorted.bam
2.2G	bam-slices/chinook_Battle.Creek.Sacramento.River_Schluter_GBC_001_CH1-2011_Male/0006-sorted.bam
```
Note that this is not how you want to rip through files, typically, because it is slow and awk is a much
better bet. But, if you want to do a system call for each line, it ends up being a decent way forward.


## More stuff

In here, let's also talk about compression with gzip (and using `stuff | gzip -c > this.gz` to gzip and send to stdout.)
